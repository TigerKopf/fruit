# Dockerfile.prod

# Verwende das offizielle NGINX Alpine Image als Basis
FROM nginx:alpine

# Verwenden einer ARG für die PHP-Version für bessere Flexibilität
# Überprüfen Sie mit 'docker run --rm nginx:alpine apk search php', welche Versionen verfügbar sind.
ARG PHP_VERSION=82 

# Aktualisiere Pakete und installiere PHP-FPM sowie wichtige PHP-Erweiterungen
RUN apk update && \
    apk add --no-cache \
    php${PHP_VERSION} \
    php${PHP_VERSION}-fpm \
    php${PHP_VERSION}-mysqli \
    php${PHP_VERSION}-json \
    php${PHP_VERSION}-gd \
    php${PHP_VERSION}-xml \
    php${PHP_VERSION}-curl \
    php${PHP_VERSION}-mbstring \
    && rm -rf /var/cache/apk/*

# Konfiguriere PHP-FPM, um Logs an stderr zu senden, im Vordergrund zu laufen und den richtigen Benutzer zu verwenden.
RUN sed -i "s/^;error_log = .*$/error_log = \/proc\/self\/fd\/2/g" /etc/php${PHP_VERSION}/php-fpm.conf && \
    sed -i "s/^;daemonize = yes$/daemonize = no/g" /etc/php${PHP_VERSION}/php-fpm.conf && \
    sed -i "s/^;catch_workers_output = yes$/catch_workers_output = yes/g" /etc/php${PHP_VERSION}/php-fpm.d/www.conf && \
    sed -i "s/^listen = .*$/listen = 127.0.0.1:9000/g" /etc/php${PHP_VERSION}/php-fpm.d/www.conf && \
    sed -i "s/^user = nobody$/user = nginx/g" /etc/php${PHP_VERSION}/php-fpm.d/www.conf && \
    sed -i "s/^group = nobody$/group = nginx/g" /etc/php${PHP_VERSION}/php-fpm.d/www.conf

# Erstelle die NGINX-Konfigurationsdatei direkt im Dockerfile mittels HEREDOC
# Dies ist robuster als ein einzelner langer 'echo'-Befehl.
RUN install -m 0644 /dev/null /etc/nginx/nginx.conf && cat << 'EOF' > /etc/nginx/nginx.conf
worker_processes auto;
events {
    worker_connections 1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.php index.html index.htm;
        location / {
            try_files $uri $uri/ =404;
        }
        location ~ \.php$ {
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_param PATH_INFO $fastcgi_path_info;
        }
    }
}
EOF

# Kopiere die PHP- und HTML-Dateien in das NGINX-Standardverzeichnis
COPY ./web /usr/share/nginx/html

# Setze korrekte Berechtigungen für die Webdateien, damit NGINX und PHP-FPM sie lesen können.
RUN chown -R nginx:nginx /usr/share/nginx/html && chmod -R 755 /usr/share/nginx/html

# Erstelle das Entrypoint-Skript direkt im Dockerfile mittels HEREDOC und mache es ausführbar
RUN install -m 0755 /dev/null /usr/local/bin/docker-entrypoint.sh && cat << 'EOF' > /usr/local/bin/docker-entrypoint.sh
#!/bin/sh
set -e

echo "Starting PHP-FPM..."
# Starte PHP-FPM im Vordergrund, aber als Hintergrundprozess des Skripts
# Wir erfassen die PID, um später zu überprüfen, ob es noch läuft.
/usr/sbin/php-fpm -F &
PHP_FPM_PID=$!

# Gib PHP-FPM einen Moment, um vollständig zu starten
sleep 2

# Überprüfe, ob PHP-FPM tatsächlich läuft
if ! ps -p $PHP_FPM_PID > /dev/null; then
    echo "ERROR: PHP-FPM konnte nicht gestartet werden oder ist sofort abgestürzt!"
    # Wenn PHP-FPM abstürzt, beenden wir das Skript, was den Container beendet.
    exit 1
fi
echo "PHP-FPM (PID $PHP_FPM_PID) läuft."

echo "Testing NGINX configuration..."
# Überprüfe die NGINX-Konfiguration auf Syntaxfehler.
# Wenn ein Fehler gefunden wird, beendet 'nginx -t' mit einem Fehlercode,
# was dank 'set -e' das Skript und den Container beendet.
nginx -t

echo "Starting NGINX in foreground..."
# Starte NGINX im Vordergrund als Hauptprozess des Containers.
# Wenn NGINX fehlschlägt, wird der Container beendet.
exec nginx -g "daemon off;"
EOF

# Expose Port 80 (der Standardport, auf dem NGINX lauscht)
EXPOSE 80

# Starte NGINX und PHP-FPM mit dem benutzerdefinierten Entrypoint-Skript
CMD ["docker-entrypoint.sh"]